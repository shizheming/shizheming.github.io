<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
<p>全局作用域拥有最长的生命周期，跨越整个程序，网页不关闭一直都会存在。</p>
<p>词法作用域是指一个变量的可见性。</p>
<pre>
aVariable = 'Outer';

function afun() {
	var aVariable = 'Middle';

	return _.map([1, 2, 3], function(e) {
		var aVariable = 'In';

		return [aVariable, e].join(' ');
	});
}

afun();
// ['In 1', 'In 2', 'In 3']
</pre>
<p>简单的情况下，变量的查找开始于最接近的绑定上下文而向外扩张，直到找到第一个绑定。</p>
<p>动态作用域（this，with）有待探讨</p>
<p>闭包是一个函数，该函数在生成时会“捕获”作用域内的外部绑定。</p>
<p>闭包的最简单的例子是一等函数，捕获局部变量供以后使用：</p>
<pre>
function whatWasTheLocal() {
	var CAPTURED = 'Oh hai';

	return function() {
		return 'The local was: ' + CAPTURED;
	};
}

var reportLocal = whatWasTheLocal();

reportLocal();
// 'The local was: Oh hai'
</pre>
<p>我已经谈到了函数的局部变量的生命周期只限于在函数体内，但是当一个闭包捕获这个变量，它一定程度上还是能继续存在。</p>
<p>如此看来，局部变量CAPTURED好像能够通过whatWasTheLocal返回的闭包被得到，实际上就是这么回事。但局部变量并不是唯一可以捕获的东西。函数参数也是可以被捕获的：</p>
<pre>
function createScaleFunction(FACTOR) {
	return function(v){
		return _.map(v, function(n)) {
			return (n * FACTOR);
		}
	};
}

var scale10 = createScaleFunction(10);

scale10([1, 2, 3]);
// [10, 20, 30]
</pre>







<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>全局作用域拥有最长的生命周期，跨越整个程序，网页不关闭一直都会存在。</p>

<p>词法作用域是指一个变量的可见性。</p>

<pre>aVariable = 'Outer';

function afun() {
    var aVariable = 'Middle';

    return _.map([1, 2, 3], function(e) {
        var aVariable = 'In';

        return [aVariable, e].join(' ');
    });
}

afun();
// ['In 1', 'In 2', 'In 3']
</pre>

<p>简单的情况下，变量的查找开始于最接近的绑定上下文而向外扩张，直到找到第一个绑定。</p>

<p>动态作用域（this，with）有待探讨</p>

<p>闭包是一个函数，该函数在生成时会“捕获”作用域内的外部绑定。</p>

<p>闭包的最简单的例子是一等函数，捕获局部变量供以后使用：</p>

<pre>function whatWasTheLocal() {
    var CAPTURED = 'Oh hai';

    return function() {
        return 'The local was: ' + CAPTURED;
    };
}

var reportLocal = whatWasTheLocal();

reportLocal();
// 'The local was: Oh hai'
</pre>

<p>我已经谈到了函数的局部变量的生命周期只限于在函数体内，但是当一个闭包捕获这个变量，它一定程度上还是能继续存在。</p>

<p>如此看来，局部变量CAPTURED好像能够通过whatWasTheLocal返回的闭包被得到，实际上就是这么回事。但局部变量并不是唯一可以捕获的东西。函数参数也是可以被捕获的：</p>

<pre>function createScaleFunction(FACTOR) {
    return function(v){
        return _.map(v, function(n)) {
            return (n * FACTOR);
        }
    };
}

var scale10 = createScaleFunction(10);

scale10([1, 2, 3]);
// [10, 20, 30]
</pre>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "fn1/3.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
