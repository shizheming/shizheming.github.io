<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
<p>全局作用域拥有最长的生命周期，跨越整个程序，网页不关闭一直都会存在。</p>
<p>词法作用域是指一个变量的可见性。</p>
<pre>
aVariable = 'Outer';

function afun() {
	var aVariable = 'Middle';

	return _.map([1, 2, 3], function(e) {
		var aVariable = 'In';

		return [aVariable, e].join(' ');
	});
}

afun();
// ['In 1', 'In 2', 'In 3']
</pre>
<p>简单的情况下，变量的查找开始于最接近的绑定上下文而向外扩张，直到找到第一个绑定。</p>
<p>动态作用域（this，with）有待探讨</p>
<p>闭包是一个函数，该函数在生成时会“捕获”作用域内的外部绑定。</p>
<p>闭包的最简单的例子是一等函数，捕获局部变量供以后使用：</p>
<pre>
function whatWasTheLocal() {
	var CAPTURED = 'Oh hai';

	return function() {
		return 'The local was: ' + CAPTURED;
	};
}

var reportLocal = whatWasTheLocal();

reportLocal();
// 'The local was: Oh hai'
</pre>
<p>我已经谈到了函数的局部变量的生命周期只限于在函数体内，但是当一个闭包捕获这个变量，它一定程度上还是能继续存在。</p>
<p>如此看来，局部变量CAPTURED好像能够通过whatWasTheLocal返回的闭包被得到，实际上就是这么回事。但局部变量并不是唯一可以捕获的东西。函数参数也是可以被捕获的：</p>
<pre>
function createScaleFunction(FACTOR) {
	return function(v){
		return _.map(v, function(n)) {
			return (n * FACTOR);
		}
	};
}

var scale10 = createScaleFunction(10);

scale10([1, 2, 3]);
// [10, 20, 30]
</pre>
<p>捕捉到的值可以是任何类型，包括函数。下面这个函数averageDamp，捕获一个函数，并返回一个计算该函数结果与另一个值得平均值函数。</p>
<pre>
function average(array) {
	var sum = _.reduce(array, function(a, b) {
		return a + b;
	});
	return sum / _.size(array);
}

function averageDamp(FUN) {
	return function(n) {
		return average([n, FUN(n)]);
	};
}

var averageSq = averageDamp(function(n) {
	return n * n;
});
averageSq(10);
// 55
</pre>
<p>捕获其他函数的高阶函数是构建抽象的强大技术。</p>
<p>如果你回想一下Applicative编程的例子，complement函数接受一个谓词，并返回一个反转谓词的函数。当时没有点明，其实complement已经将闭包用到了极致。</p>
<p>谓词函数PRED被返回的函数捕获，我们创建一个判断偶数的谓词函数，然后我们可以用complement来定义判断奇数的函数isOdd。</p>
<pre>
function complement(PRED) {
	return function() {
		return !PRED.apply(null, _.toArray(arguments));
	};
}

function isEven(n) {
	return (n % 2) === 0;
}

var isOdd = complement(isEven);

isOdd(2);
// false

isOdd(413);
// true
</pre>
<p>但如果isEven之后发生变化呢？是否会改变isOdd的行为呢？正如你所看到的，变量的捕获发生在创建闭包的时候（这个例子里的PRED）。因为我通过一个新的变量创建了新的isEven引用，所以这种变化不会被isOdd察觉的。</p>
<pre>
function isEven(n) {
	return false;
}

isEven(13);
// false

isOdd(13);
// true

isOdd(12);
// false
</pre>
<p>让我们运行下列代码：好像都对，不是吗？不完全是：</p>
<pre>
function showObject(OBJ) {
	return function() {
		return OBJ;
	};
}

var o = {
	a : 42
};
var show0 = showObject(o);

show0();
/*{
	a : 42
}*/

o.newField = 108;
show0();
/*{
	a : 42,
	newField : 108
}*/
</pre>
<p>由于o的引用同时在于闭包内部和外部，他的变化可以跨越看似私有的界限。这很容易导致混乱，所以通常的使用情况是最大限度地减少暴露捕获变量的风险。javascript经常使用下面这种模式，把捕获的变量作为私有数据：</p>
<pre>
var pingpong = (function() {
	var PRIVATE = 0;

	return {
		inc : function(n) {
			return PRIVATE += n;
		},
		dec : function(n) {
			return PRIVATE -= n;
		}
	};
})();

pingpong.inc(10);
// 10

pingpong(7);
// 3

pingpong.div = function(n) {
	return PRIVATE / n;
};

pingpong.div(3);
// ReferenceError: PRIVATE is not defined
</pre>
<p>对象pingpong是由块作用域的匿函数构建，并包含两个闭包inc和dec。最有趣的部分是，捕获的变量PRIVATE是两个闭包的私有变量，除了通过调用这两个函数之一，无法通过任何手段进行访问，所以当我们添加了div的方法去访问这个变量的时候也是安全的。</p>
<p>通过这种闭包模式提供访问保护是一种强大的技术。</p>

<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>全局作用域拥有最长的生命周期，跨越整个程序，网页不关闭一直都会存在。</p>

<p>词法作用域是指一个变量的可见性。</p>

<pre>aVariable = 'Outer';

function afun() {
    var aVariable = 'Middle';

    return _.map([1, 2, 3], function(e) {
        var aVariable = 'In';

        return [aVariable, e].join(' ');
    });
}

afun();
// ['In 1', 'In 2', 'In 3']
</pre>

<p>简单的情况下，变量的查找开始于最接近的绑定上下文而向外扩张，直到找到第一个绑定。</p>

<p>动态作用域（this，with）有待探讨</p>

<p>闭包是一个函数，该函数在生成时会“捕获”作用域内的外部绑定。</p>

<p>闭包的最简单的例子是一等函数，捕获局部变量供以后使用：</p>

<pre>function whatWasTheLocal() {
    var CAPTURED = 'Oh hai';

    return function() {
        return 'The local was: ' + CAPTURED;
    };
}

var reportLocal = whatWasTheLocal();

reportLocal();
// 'The local was: Oh hai'
</pre>

<p>我已经谈到了函数的局部变量的生命周期只限于在函数体内，但是当一个闭包捕获这个变量，它一定程度上还是能继续存在。</p>

<p>如此看来，局部变量CAPTURED好像能够通过whatWasTheLocal返回的闭包被得到，实际上就是这么回事。但局部变量并不是唯一可以捕获的东西。函数参数也是可以被捕获的：</p>

<pre>function createScaleFunction(FACTOR) {
    return function(v){
        return _.map(v, function(n)) {
            return (n * FACTOR);
        }
    };
}

var scale10 = createScaleFunction(10);

scale10([1, 2, 3]);
// [10, 20, 30]
</pre>

<p>捕捉到的值可以是任何类型，包括函数。下面这个函数averageDamp，捕获一个函数，并返回一个计算该函数结果与另一个值得平均值函数。</p>

<pre>function average(array) {
    var sum = _.reduce(array, function(a, b) {
        return a + b;
    });
    return sum / _.size(array);
}

function averageDamp(FUN) {
    return function(n) {
        return average([n, FUN(n)]);
    };
}

var averageSq = averageDamp(function(n) {
    return n * n;
});
averageSq(10);
// 55
</pre>

<p>捕获其他函数的高阶函数是构建抽象的强大技术。</p>

<p>如果你回想一下Applicative编程的例子，complement函数接受一个谓词，并返回一个反转谓词的函数。当时没有点明，其实complement已经将闭包用到了极致。</p>

<p>谓词函数PRED被返回的函数捕获，我们创建一个判断偶数的谓词函数，然后我们可以用complement来定义判断奇数的函数isOdd。</p>

<pre>function complement(PRED) {
    return function() {
        return !PRED.apply(null, _.toArray(arguments));
    };
}

function isEven(n) {
    return (n % 2) === 0;
}

var isOdd = complement(isEven);

isOdd(2);
// false

isOdd(413);
// true
</pre>

<p>但如果isEven之后发生变化呢？是否会改变isOdd的行为呢？正如你所看到的，变量的捕获发生在创建闭包的时候（这个例子里的PRED）。因为我通过一个新的变量创建了新的isEven引用，所以这种变化不会被isOdd察觉的。</p>

<pre>function isEven(n) {
    return false;
}

isEven(13);
// false

isOdd(13);
// true

isOdd(12);
// false
</pre>

<p>让我们运行下列代码：好像都对，不是吗？不完全是：</p>

<pre>function showObject(OBJ) {
    return function() {
        return OBJ;
    };
}

var o = {
    a : 42
};
var show0 = showObject(o);

show0();
/*{
    a : 42
}*/

o.newField = 108;
show0();
/*{
    a : 42,
    newField : 108
}*/
</pre>

<p>由于o的引用同时在于闭包内部和外部，他的变化可以跨越看似私有的界限。这很容易导致混乱，所以通常的使用情况是最大限度地减少暴露捕获变量的风险。javascript经常使用下面这种模式，把捕获的变量作为私有数据：</p>

<pre>var pingpong = (function() {
    var PRIVATE = 0;

    return {
        inc : function(n) {
            return PRIVATE += n;
        },
        dec : function(n) {
            return PRIVATE -= n;
        }
    };
})();

pingpong.inc(10);
// 10

pingpong(7);
// 3

pingpong.div = function(n) {
    return PRIVATE / n;
};

pingpong.div(3);
// ReferenceError: PRIVATE is not defined
</pre>

<p>对象pingpong是由块作用域的匿函数构建，并包含两个闭包inc和dec。最有趣的部分是，捕获的变量PRIVATE是两个闭包的私有变量，除了通过调用这两个函数之一，无法通过任何手段进行访问，所以当我们添加了div的方法去访问这个变量的时候也是安全的。</p>

<p>通过这种闭包模式提供访问保护是一种强大的技术。</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "fn1/3.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
