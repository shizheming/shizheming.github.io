<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
<p>可以传递给其他函数的函数，可以从函数返回的函数，定义为高阶函数。</p>
<p>以其他函数为参数的函数</p>
<p>首先，让我们从一个很简单的函数repeat开始。他以一个数字和一个值为参数，将该值进行多次复制，并放入一个数组当中：</p>
<pre>
function repeat(times, VALUE) {
	return _.map(_.range(times), function() {
		return VALUE;
	});
}

repeat(4, 'Major');
// ['Major', 'Major', 'Major', 'Major']
</pre>
<p>repeat的实现使用_.map函数来遍历从0到times-1的数组，并将VALUE丢到数组中。这里我主要用他来强调一个很重要的观点，可概括为“使用函数，而不是值”。</p>
<p>也就是说，当一个函数将一个值重复多次是可以的，但将运算重复多次则更好。我略微地修改了一下repeat，按如下方式来执行：</p>
<pre>
function repeatedly(times, fun) {
	return _.map(_.range(times), fun);
}

repeatedly(3, function() {
	return Math.floor((Math.random() * 10) + 1);
});
// [1, 3, 8]

repeatedly(3, function() {
	return 'Odelay';
})
// ['Odelay', 'Odelay', 'Odelay']
</pre>
<p>函数repeatedly是展示函数式思维方式力量的一个很好的例证。通过将参数从值替换为函数，我们打开了一个充满可能性的世界，与repeat类似，在调用端，我们可以用一个可以填充任何东西的数组来替换一个固定的值。如果我们真的想在repeatedly中用常量，那么我们直接把常量用函数返回出去就行了，就像上面第二次调用的那样做。</p>
<p>我已经将一个在repeat中使用静态值的函数变成了接收一个函数的repeatedly函数。虽然这确实使repeatedly更加开放，但他的通用性仍然没有达到预期。我们仍然需要一个确定需要调用给定的函数多少次的数值。但有时候也知道什么时候退出并不取决于“次数”，而是条件。换句话说，你可能需要不断调用一个函数，直到他的返回值超过了某个阈值，这样一来，一个简单的值是远远不够的，相反，我们定义另一个名为iterateUntil的函数，来解决这个问题：</p>
<pre>
function iterateUntil(fun, check, init) {
	var ret = [];
	var result = fun(init);

	while (check(result)) {
		ret.push(result);
		result = fun(result);
	}

	return ret;
}

iterateUntil(function(n) {
	return n + n;
}, function(n) {
	return n <= 1024;
});
// [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
</pre>
<p>函数iterateUntil接收两个函数：一个用来执行一些动作，另外一个用来进行结果检查，当结果满足“结束”值时返回false。这算得上是真正将repeatedly带到了一个新的水平，现在甚至连重复次数都是开放的。这里假设你想找到所有大于2小于1024的2的倍数。</p>
<p>iterateUntil提供的另外一个优点是，循环体是一个前馈函数。换句话说，一些函数的执行结果被当做下一个函数的参数。我将会在“管道”一节展示这种条件结束的强大。</p>
<p>返回其他函数的函数</p>
<p>我们以回忆repeatedly作为开始：他忽略其参数并仅仅返回一个常量的函数，这种返回一个常量的函数非常有用，所以几乎是函数式编程的一个设计模式，经常简称为k，然而，为了清晰起见，我称为always，其实现方式如下所示：</p>
<pre>
function always(VALUE) {
    return function() {
        return VALUE;
    };
}
</pre>
<p>一个为什么你可能需要创建一个以函数为返回值的函数的理由是，高阶函数的参数是用来“配置”返回函数的行为的，对于高阶函数makeAdder而言，他的参数配置了其返回函数每次添加数值的太小。</p>
<pre>
var add100 = makeAdder(100);
add100(38);
// 138
</pre>
<p>假设你需要一个能够生成唯一字符串的函数。实现可能如下所示：</p>
<pre>
function uniqueString(len) {
    return Math.random().toString(36).substr(2, len);
}

uniqueString(10);
// '3rm6ww5w0x'
</pre>
<p>然而，如果需要生成具有特定前缀的唯一字符串，改怎么办？可将uniqueString修改为：</p>
<pre>
function uniqueString(prefix) {
    return [prefix, new Date().getTime()].join('');
}

uniqueString('argento');
// 'argento1356107740868'
</pre>
<p>新uniqueString似乎可以工作。但是，如果需要再次变更，需要返回一个添加了前缀，并且后缀从某一个值开始增长的字符串，改怎么办？在这种情况下，新的实现可以用闭包来捕获增加值，并用作后缀：</p>
<pre>
function makeUniqueStringFunction(start) {
    var COUNTER = start;
    return function(prefix) {
        return [prefix, COUNTER++].join('');
    };
}

var uniqueString = makeUniqueStringFunction(0);

uniqueString('dari');
// 'dari0'

uniqueString('dari');
// 'dari1'
</pre>
<p>上面这个返回函数同时去捕获配置值的函数，在我看来就是一个移动的独立作用域，如果没有最外面那层，就是上面一个变量，下面一个函数，然后函数没运行一次，变量++，扒了外面那层，里面就很好理解了</p>
<p>对于makeUniqueStringFunction函数，变量COUNTER被函数返回并捕获。这似乎工作的很好，但我们能不能在一个对象上实现相同的功能？列如：</p>
<pre>
var generator = {
    count : 0,
    uniqueString : function(prefix) {
        return [prefix, this.count++].join('');
    }
};

generator.uniqueString('bohr');
// 'bohr0';

generator.uniqueString('bohr');
// 'bohr1';

generator.count = 'gotcha';
generator.uniqueString('bohr');
// 'borhorNaN'
generator.uniqueString.call({
    count : 1337,
    'bohr'
});
// 'bohr1337'
</pre>
<p>但他有一个缺点（除了他不是函数式），即不够安全，此时，事实上你的系统处于一个危险的状态。makeUniqueStringFunction所使用的方法隐藏了COUNTER。也就是说，COUNTER变量是返回闭包“私有”的。现在我并不是在讲究私有变量和对象属性，但有时候隐藏关键实现细节是很重要的。事实上我们可以使用JavaScript的秘密武器将COUNTER隐藏在generator中：</p>
<pre>
var omgenerator = (function(init) {
    var COUNTER = init;

    return {
        uniqueString : function(prefix) {
            return [prefix, COUNTER++].join('');
        }
    };
})(0);

omgenerator.uniqueString('lichking-');
// 'lichking-0'
</pre>
<p>但值得指出的是，我会避免类似于makeUniqueStringFunctions这样的函数，除非他们是必要的。相反，我觉得你会很惊讶的发现在函数式编程中对状态的改变要求甚少。你需要时间来改变你的思维方式</p>
<p>防止不存在的函数：fnull</p>
<p>假设我们有一组需要执行乘法的数字数组，另一种有问题的场景是：一个函数接收一个配置对象作为输入来执行一些动作：</p>
<pre>
var nums = [1, 2, 3, null, 5];

_.reduce(nums, function(total, n) {
    return total * n;
});
// 0

doSomething({
    whoCares : 42,
    critical : null
});
</pre>
<p>在这两种情况下，有一个fnull函数将是很有用的。fnull接收一个函数及一些额外的参数，并返回一个只是调用给定的原始函数的函数，fnull神奇的地方在于，对于任何事null或undefined的参数，都用原来“默认”的参数来代替。这里将要展示的fnull是实现最为复杂的高阶函数，但他仍然是相当合理的。注意观察以下代码：</p>
<pre>
function fnull(fun /*, defaults */) {
    var defaults = _.rest(arguments);

    return function(/* args */) {
        var args = _.map(arguments, function(e, i) {
            return existy(e) ? e : defaults[i];
        });

        return fun.apply(null, args);
    };
}

var safeMult = fnull(function(total, n) {
    return total * n;
}, 1, 1);

_.reduce(nums, safeMult);
// 30
</pre>
<p>为了解决配置对象的问题，可以通过以下方式来使用fnull：</p>
<pre>
function defaults(d) {
    return function(o, k) {
        var val = fnull(_.identity, d[k]);
        return o && val(o[k]);
    };
}

function doSomething(config) {
    var lookup = defaults({
        critical : 108
    });

    return lookup(config, 'critical');
}

doSomething({
    critical : 9
});
// 9

doSomething({});
// 108
</pre>
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>可以传递给其他函数的函数，可以从函数返回的函数，定义为高阶函数。</p>

<p>以其他函数为参数的函数</p>

<p>首先，让我们从一个很简单的函数repeat开始。他以一个数字和一个值为参数，将该值进行多次复制，并放入一个数组当中：</p>

<pre>function repeat(times, VALUE) {
    return _.map(_.range(times), function() {
        return VALUE;
    });
}

repeat(4, 'Major');
// ['Major', 'Major', 'Major', 'Major']
</pre>

<p>repeat的实现使用_.map函数来遍历从0到times-1的数组，并将VALUE丢到数组中。这里我主要用他来强调一个很重要的观点，可概括为“使用函数，而不是值”。</p>

<p>也就是说，当一个函数将一个值重复多次是可以的，但将运算重复多次则更好。我略微地修改了一下repeat，按如下方式来执行：</p>

<pre>function repeatedly(times, fun) {
    return _.map(_.range(times), fun);
}

repeatedly(3, function() {
    return Math.floor((Math.random() * 10) + 1);
});
// [1, 3, 8]

repeatedly(3, function() {
    return 'Odelay';
})
// ['Odelay', 'Odelay', 'Odelay']
</pre>

<p>函数repeatedly是展示函数式思维方式力量的一个很好的例证。通过将参数从值替换为函数，我们打开了一个充满可能性的世界，与repeat类似，在调用端，我们可以用一个可以填充任何东西的数组来替换一个固定的值。如果我们真的想在repeatedly中用常量，那么我们直接把常量用函数返回出去就行了，就像上面第二次调用的那样做。</p>

<p>我已经将一个在repeat中使用静态值的函数变成了接收一个函数的repeatedly函数。虽然这确实使repeatedly更加开放，但他的通用性仍然没有达到预期。我们仍然需要一个确定需要调用给定的函数多少次的数值。但有时候也知道什么时候退出并不取决于“次数”，而是条件。换句话说，你可能需要不断调用一个函数，直到他的返回值超过了某个阈值，这样一来，一个简单的值是远远不够的，相反，我们定义另一个名为iterateUntil的函数，来解决这个问题：</p>

<pre>function iterateUntil(fun, check, init) {
    var ret = [];
    var result = fun(init);

    while (check(result)) {
        ret.push(result);
        result = fun(result);
    }

    return ret;
}

iterateUntil(function(n) {
    return n + n;
}, function(n) {
    return n &lt;= 1024;
});
// [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
</pre>

<p>函数iterateUntil接收两个函数：一个用来执行一些动作，另外一个用来进行结果检查，当结果满足“结束”值时返回false。这算得上是真正将repeatedly带到了一个新的水平，现在甚至连重复次数都是开放的。这里假设你想找到所有大于2小于1024的2的倍数。</p>

<p>iterateUntil提供的另外一个优点是，循环体是一个前馈函数。换句话说，一些函数的执行结果被当做下一个函数的参数。我将会在“管道”一节展示这种条件结束的强大。</p>

<p>返回其他函数的函数</p>

<p>我们以回忆repeatedly作为开始：他忽略其参数并仅仅返回一个常量的函数，这种返回一个常量的函数非常有用，所以几乎是函数式编程的一个设计模式，经常简称为k，然而，为了清晰起见，我称为always，其实现方式如下所示：</p>

<pre>function always(VALUE) {
    return function() {
        return VALUE;
    };
}
</pre>

<p>一个为什么你可能需要创建一个以函数为返回值的函数的理由是，高阶函数的参数是用来“配置”返回函数的行为的，对于高阶函数makeAdder而言，他的参数配置了其返回函数每次添加数值的太小。</p>

<pre>var add100 = makeAdder(100);
add100(38);
// 138
</pre>

<p>假设你需要一个能够生成唯一字符串的函数。实现可能如下所示：</p>

<pre>function uniqueString(len) {
    return Math.random().toString(36).substr(2, len);
}

uniqueString(10);
// '3rm6ww5w0x'
</pre>

<p>然而，如果需要生成具有特定前缀的唯一字符串，改怎么办？可将uniqueString修改为：</p>

<pre>function uniqueString(prefix) {
    return [prefix, new Date().getTime()].join('');
}

uniqueString('argento');
// 'argento1356107740868'
</pre>

<p>新uniqueString似乎可以工作。但是，如果需要再次变更，需要返回一个添加了前缀，并且后缀从某一个值开始增长的字符串，改怎么办？在这种情况下，新的实现可以用闭包来捕获增加值，并用作后缀：</p>

<pre>function makeUniqueStringFunction(start) {
    var COUNTER = start;
    return function(prefix) {
        return [prefix, COUNTER++].join('');
    };
}

var uniqueString = makeUniqueStringFunction(0);

uniqueString('dari');
// 'dari0'

uniqueString('dari');
// 'dari1'
</pre>

<p>上面这个返回函数同时去捕获配置值的函数，在我看来就是一个移动的独立作用域，如果没有最外面那层，就是上面一个变量，下面一个函数，然后函数没运行一次，变量++，扒了外面那层，里面就很好理解了</p>

<p>对于makeUniqueStringFunction函数，变量COUNTER被函数返回并捕获。这似乎工作的很好，但我们能不能在一个对象上实现相同的功能？列如：</p>

<pre>var generator = {
    count : 0,
    uniqueString : function(prefix) {
        return [prefix, this.count++].join('');
    }
};

generator.uniqueString('bohr');
// 'bohr0';

generator.uniqueString('bohr');
// 'bohr1';

generator.count = 'gotcha';
generator.uniqueString('bohr');
// 'borhorNaN'
generator.uniqueString.call({
    count : 1337,
    'bohr'
});
// 'bohr1337'
</pre>

<p>但他有一个缺点（除了他不是函数式），即不够安全，此时，事实上你的系统处于一个危险的状态。makeUniqueStringFunction所使用的方法隐藏了COUNTER。也就是说，COUNTER变量是返回闭包“私有”的。现在我并不是在讲究私有变量和对象属性，但有时候隐藏关键实现细节是很重要的。事实上我们可以使用JavaScript的秘密武器将COUNTER隐藏在generator中：</p>

<pre>var omgenerator = (function(init) {
    var COUNTER = init;

    return {
        uniqueString : function(prefix) {
            return [prefix, COUNTER++].join('');
        }
    };
})(0);

omgenerator.uniqueString('lichking-');
// 'lichking-0'
</pre>

<p>但值得指出的是，我会避免类似于makeUniqueStringFunctions这样的函数，除非他们是必要的。相反，我觉得你会很惊讶的发现在函数式编程中对状态的改变要求甚少。你需要时间来改变你的思维方式</p>

<p>防止不存在的函数：fnull</p>

<p>假设我们有一组需要执行乘法的数字数组，另一种有问题的场景是：一个函数接收一个配置对象作为输入来执行一些动作：</p>

<pre>var nums = [1, 2, 3, null, 5];

_.reduce(nums, function(total, n) {
    return total * n;
});
// 0

doSomething({
    whoCares : 42,
    critical : null
});
</pre>

<p>在这两种情况下，有一个fnull函数将是很有用的。fnull接收一个函数及一些额外的参数，并返回一个只是调用给定的原始函数的函数，fnull神奇的地方在于，对于任何事null或undefined的参数，都用原来“默认”的参数来代替。这里将要展示的fnull是实现最为复杂的高阶函数，但他仍然是相当合理的。注意观察以下代码：</p>

<pre>function fnull(fun /*, defaults */) {
    var defaults = _.rest(arguments);

    return function(/* args */) {
        var args = _.map(arguments, function(e, i) {
            return existy(e) ? e : defaults[i];
        });

        return fun.apply(null, args);
    };
}

var safeMult = fnull(function(total, n) {
    return total * n;
}, 1, 1);

_.reduce(nums, safeMult);
// 30
</pre>

<p>为了解决配置对象的问题，可以通过以下方式来使用fnull：</p>

<pre>function defaults(d) {
    return function(o, k) {
        var val = fnull(_.identity, d[k]);
        return o &amp;&amp; val(o[k]);
    };
}

function doSomething(config) {
    var lookup = defaults({
        critical : 108
    });

    return lookup(config, 'critical');
}

doSomething({
    critical : 9
});
// 9

doSomething({});
// 108
</pre>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "fn1/4.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
